#include <cpen333/process/subprocess.h>
#include <cpen333/process/shared_memory.h>
#include <chrono>
#include <thread>
#include <string>
#include <iostream>
#include <cpen333/process/mutex.h>
#include "malware.h"

// Usage:
//    malware <name> <index>
// name is any name
// index is 0 or 1
// defaults to name:malware, index:0

struct SharedMal{
	int sharedArr[2];
	int numProcesses = 0;
};

int main(int argc, char* argv[]) {

	// extract name and index
	int index = 0;
	std::string name = "malware";
	if (argc > 1) {
		name = argv[1];
	}
	if (argc > 2) {
		index = std::atoi(argv[2]);
	}

	std::cout << name << " " << std::to_string(index) << " started" << std::endl;

	//========================================================
	// TODO: CREATE AND INITIALIZE SHARED MEMORY
	//========================================================
	cpen333::process::shared_object<SharedMal> sharedMemoryMal("malware_shared");
	//comment out initializing these to 0 to demo malware restarting a lot
	sharedMemoryMal->sharedArr[0] = 0;
	sharedMemoryMal->sharedArr[1] = 0;
	int oindex = (index + 1) % 2;  // index of other malware process

	while (true) {
		std::cout << name << " " << std::to_string(index) << " running" << std::endl;

		//=======================================================
		// TODO: CHECK IF OTHER PROCESS MISSED CHECK-IN(S)
		//       - LAUNCH IF NOT RESPONDING
		//=======================================================

		if (abs(sharedMemoryMal->sharedArr[index] - sharedMemoryMal->sharedArr[oindex]) > 2){
			sharedMemoryMal->numProcesses++;
			if (sharedMemoryMal->numProcesses++ <= 3){ //so you don't get overwhelming num of new processes
				std::cout << "process " << oindex << " is inactive, restarting it" << std::endl;
				std::vector<std::string> cmd;
				cmd.push_back("malware.exe");
				cmd.push_back(name);
				cmd.push_back(std::to_string(oindex));
				cpen333::process::subprocess proc(cmd, true, true);
			}
		}

		sharedMemoryMal->sharedArr[index]++;
		std::cout << "process " << index << " value: " << sharedMemoryMal->sharedArr[index] << std::endl;
		std::this_thread::sleep_for(std::chrono::seconds(10));
	}

	return 0;
}